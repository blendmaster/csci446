# IE9 fix, since it doesn't support the hidden attribute
for el of document.querySelectorAll '*[hidden]'
	el.style.display = \none

hide = ->
	it.hidden = true
	it.style.display = \none

show = ->
	it.hidden = false
	it.style.removeProperty \display

<- window.addEventListener \load
# DOM interfacing

canvas = document.getElementById \canvas
{width, height} = canvas
ctx = canvas.getContext \2d


# image assets
assets = {}
for img of document.getElementById \assets .children
	assets[img.id] = img

# shortcut to draw image assets to the screen
ctx.render = -> @drawImage do
	assets[it] or throw new Error "asset #it doesn't exist!"
	0
	0

# set font to something clos to my handwriting

# good ol vendor prefixes
window.requestAnimationFrame = 
	window.requestAnimationFrame or
	window.mozRequestAnimationFrame or
	window.webkitRequestAnimationFrame or
	window.msRequestAnimationFrame or
	window.oRequestAnimationFrame or
	-> window.setTimeout it, 1000ms / 60frames

window.cancelAnimationFrame = 
	window.cancelAnimationFrame or
	window.mozCancelAnimationFrame or
	window.webkitCancelAnimationFrame or
	window.msCancelAnimationFrame or
	window.oCancelAnimationFrame or
	-> window.clearTimeout it

# balancing constants
stop = [ 4 12 18 ] # where there is a trampoline check 
end = 21positions
move_delay = 38frames
trampoline_delay = 8frames
std_dev = 5moves # controls how random next players are
# exponential difficulty curve, giving a new player at an average of
# 7 moves after 100 turns
# FIXME this is a stupid difficulty curve
difficulty_curve = Math.pow( Math.E, Math.log( 2moves / 5points ) )

# high score handling
if localStorage?\high_scores
	high_scores = JSON.parse that # localstorage only stores strings
else 
	high_scores = 
		* name: \mario score: 384
		* name: \luigi score: 253
		* name: \wario score: 231
		* name: \bowser score: 133
		* name: \toad score: 27

high_score_threshold = # minimum high score
	( high_scores.reduce (a,b) -> if a.score < b.score then a else b ).score

add_high_score = !(points) ->
	high_scores.push do
		name: window.prompt('You got a high score! enter your name:','').substr(0,10) || \anonymous
		score: points

	# sort decending and take 5 highest
	high_scores.:=sort( (a,b) -> b.score - a.score ).slice 0 5
	localStorage.\high_scores = JSON.stringify( high_scores ) if localStorage # persist

high_scores_el = document.getElementById \high-scores

hide_high_scores = -> hide high_scores_el

show_high_scores = !->
	list = ''
	list += "<li>#{h.name} : #{h.score}</li>" for h of high_scores

	high_scores_el.innerHTML = list
	show high_scores_el

# game data, closed over in functions
# all initialized to void, so coco will declare them in the right scope
# in vanilla javascript, they'd be empty var declarations, but such is the
# price we must pay for non-vanilla javascript
people = void # list of people on screen
trampoline = void # position of trampoline
points = void
misses = void
next_person = void # the number of frames until the next person appears
frame = void # id of the next frame, for canceling

draw = !->
	ctx.clearRect 0 0 width, height
	ctx.render \bg

	ctx.font = '12px "Gloria Hallelujah"'
	ctx.fillText points, 155 16
	ctx.render "#{misses}miss" if misses > 0

	ctx.render "tramp#{trampoline}"

	ctx.render p.position.toString! for p of people

tick = !->
	dropped = false # if somebody got dropped
	dirty = false # if somebody moved and a redraw is necessary

	tramp = stop[trampoline] # trampoline move position

	for p of people
		if --p.delay <= 0 # until person is due to move
			dirty = true
			p.delay = move_delay
			prev = p.position
			pos = ++p.position
			
			if stop.indexOf(pos) is not -1 # entered a bounce spot
				unless pos is tramp # trampoline is already positioned
					p.death_timer = trampoline_delay # start grace period

			if stop.indexOf(prev) is not -1 # if they were bounced
				++points
				p.bounced = false # reset flag for next bounce

		# short grace time for trampoline check, so trampoline can handle
		# multiple people in-between moves
		if p.death_timer
			if --p.death_timer is 0
				++misses
				dropped = p
				break # stop processing people

		if p.position is tramp
			p.bounced = true 
			p.death_timer = 0

	if dropped
		people.splice people.indexOf( dropped ), 1 # remove person
		drop_animation p.position
	else
		# pop first person if they're saved
		people.shift! if people.0?position is end

		if --next_person is 0
			people.push {position:0 delay: move_delay}
			# get a normally-distributed number through the central limit theorem
			avg = 0
			avg += Math.random! * 2 - 1 for i til 16 # [-1, 1) 
			avg /= 16
			# TODO better difficulty curve
			# use frame-level granularity for more interesting play
			# in the original fire, they tend to come in waves, with the delay short
			# enough to make the player have to juggle them
			next_person := 
				( Math.floor ( avg * std_dev + end/2 - Math.pow(difficulty_curve,points) ) * move_delay ) >? move_delay

		draw! if dirty
		frame := window.requestAnimationFrame tick # next frame

# map from miss position to next walkoff
walk_off_positions = 4: 0, 12: 2, 18: 3
drop_animation = !(drop_position) ->
	# temporarily prevent trampoline movement
	document.removeEventListener \keydown key_move
	canvas.removeEventListener \click click_move

	draw!
	ctx.render "miss#{drop_position}"
	
	# display walk off animation
	walk_pos = walk_off_positions[drop_position]
	
	setTimeout do
		function walk_anim
			draw!
			ctx.render "walk#{walk_pos}"
			if ++walk_pos < 5 # 4 is last walk position
				setTimeout walk_anim, 500ms 
			else
				return game_over! if misses is 3
				# re-add trampoline events and start game again
				setTimeout do
					->
						document.addEventListener \keydown key_move
						canvas.addEventListener \click click_move

						# create new person if there aren't any on screen 
						next_person := 1
						draw!
						tick!
					500ms
		500ms

game_over = !->
	if points > high_score_threshold
		add_high_score points
	
	show_high_scores!

	document.removeEventListener \keydown key_move
	canvas.removeEventListener \click click_move

	canvas.addEventListener \click click_start

	# cycle gameover for 5 seconds, then display title
	cycles = 50
	current_gameover = 0
	ctx.drawImage assets.gameover1, 0 0 width, height
	cycle_gameover = !->
		ctx.clearRect 0 0 width, height
		current_gameover := (current_gameover + 1) % 3
		ctx.drawImage assets["gameover#{current_gameover + 1}"], 0 0 width, height
		if --cycles > 0
			window.setTimeout cycle_gameover, 100ms
		else
			cycle_title!

	window.setTimeout cycle_gameover, 100ms
		

start_game = !->
	people := [{position: 0, delay: move_delay}] # start with initial person
	trampoline := 1 # middle
	points := 0
	misses := 0

	# add the next person after the first person is saved
	# after that, tick! will set next_person as a poisson process
	next_person := end * move_delay

	window.clearTimeout cycle_timeout # stop title animation
	window.cancelAnimationFrame cycle_frame # edge case: stop title animation wrapper

	document.addEventListener \keydown key_move
	canvas.addEventListener \click click_move
	
	canvas.removeEventListener \click click_start
	
	hide_high_scores!

	draw!
	tick!

click_start = ({button}: e) ->
	if button is 0 # only left click
		e.preventDefault!
		start_game!

key_move = !({keyCode}: e) -> 
	if keyCode is 37 and trampoline > 0 # left
		--trampoline
	else if keyCode is 39 and trampoline < 2 # right
		++trampoline
	else if keyCode is 27 # esape
		pause!
	draw!
	e.preventDefault!

click_move = !({clientX, clientY}: e) ->
	{left, top} = canvas.getBoundingClientRect!
	x = clientX - left
	y = clientY - top
	if x > 208 and y < 38 # top right corner
		pause!
	else if 25 < x < 97
		trampoline := 0
	else if 97 < x < 156
		trampoline := 1
	else if 156 < x < 236
		trampoline := 2
	draw!
	e.preventDefault!

pause = !->
	window.cancelAnimationFrame frame

	# wrapped in setTimeout, because somehow, there is still a 
	# draw! call waiting in the queue, so we want to run this after that
	setTimeout do
		->
			ctx.clearRect 0 0 width, height
			ctx.render \pause
		0ms

	document.removeEventListener \keydown key_move
	canvas.removeEventListener \click click_move
	canvas.addEventListener \click click_unpause

click_unpause = !->
	canvas.removeEventListener \click click_unpause
	document.addEventListener \keydown key_move
	canvas.addEventListener \click click_move
	tick!

# cheesy hand-drawn animation effect
current_title = 0
cycle_timeout = void
cycle_frame = void # Additional variable to cancel animation frame
cycle_title = !->
	ctx.clearRect 0 0 width, height
	current_title := (current_title + 1 ) % 3
	ctx.drawImage assets["title#{current_title+1}"], 0 0 width, height
	
	# wrapped in requestAnimationFrame so title won't cycle
	# when page isn't visible
	cycle_frame := window.requestAnimationFrame ->
		cycle_timeout := setTimeout cycle_title, 100ms

# add initial click to start game
cycle_title!
show_high_scores!
canvas.addEventListener \click click_start 

