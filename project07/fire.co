# deferred load, so DOMContentLoaded handler isn't necessary

# DOM interfacing

canvas = document.getElementById \canvas
{width, height} = canvas
ctx = canvas.getContext \2d

# image assets
assets = {}
for img of document.getElementById \assets .children
	assets[img.id] = img

# good ol vendor prefixes
window.requestAnimationFrame = 
	window.requestAnimationFrame or
	window.mozRequestAnimationFrame or
	window.webkitRequestAnimationFrame or
	window.msRequestAnimationFrame or
	window.oRequestAnimationFrame or
	-> window.setTimeout it, 1000ms / 60frames

window.cancelAnimationFrame = 
	window.cancelAnimationFrame or
	window.mozCancelAnimationFrame or
	window.webkitCancelAnimationFrame or
	window.msCancelAnimationFrame or
	window.oCancelAnimationFrame or
	-> window.clearTimeout it

# balancing constants
stop = [ 5 13 19 ] # where there is a trampoline check 
end = 21positions
move_delay = 35frames
trampoline_delay = 15frames
std_dev = 5moves # controls how random next players are
# exponential difficulty curve, giving a new player at an average of
# 7 moves after 100 turns
# FIXME this is a stupid difficulty curve
difficulty_curve = Math.pow( Math.E, Math.log( 2moves / 5points ) )

# high score handling
if localStorage?\high_scores
	high_scores = JSON.parse that # localstorage only stores strings
else 
	high_scores = 
		* name: \mario score: 384
		* name: \luigi score: 253
		* name: \wario score: 231
		* name: \bowser score: 133
		* name: \toad score: 3

high_score_threshold = # minimum high score
	( high_scores.reduce (a,b) -> if a.score < b.score then a else b ).score

add_high_score = !(points) ->
	high_scores.push do
		name: window.prompt('You got a high score! enter your name:').substr(0,10) || \anonymous
		score: points

	# sort decending and take 5 highest
	high_scores.:=sort( (a,b) -> b.score - a.score ).slice 0 5
	localStorage.\high_scores = JSON.stringify( high_scores ) if localStorage # persist

high_scores_el = document.getElementById \high-scores

hide_high_scores = -> high_scores_el.hidden = true

show_high_scores = !->
	list = ''
	list += "<li>#{h.name} : #{h.score}</li>" for h of high_scores

	high_scores_el.innerHTML = list
	high_scores_el.hidden = false # show element

# game data, closed over in functions
# all initialized to void, so coco will declare them in the right scope
# in vanilla javascript, they'd be empty var declarations, but such is the
# price we must pay for non-vanilla javascript
people = void # list of people on screen
trampoline = void # position of trampoline
points = void
misses = void
drop_position = void # used to draw dropped person
next_person = void # the number of frames until the next person appears

draw = !->
	ctx.clearRect 0 0 width, height

	ctx.fillText "trampoline: #{stop[trampoline]}" 0 20
	ctx.fillText "points: #{points}" 100 20
	ctx.fillText "misses: #{misses}" 150 20

	# draw person
	ctx.fillText "person: #{p.position}" p.position, 50+15*i for p,i of people

tick = !->
	dropped = false # if somebody got dropped
	dirty = false # if somebody moved and a redraw is necessary

	tramp = stop[trampoline] # trampoline move position

	for p of people
		if --p.delay is 0 # until person is due to move
			dirty = true
			p.delay = move_delay
			prev = p.position
			pos = ++p.position
			
			if stop.indexOf(pos) is not -1 # entered a bounce spot
				unless pos is tramp # trampoline is already positioned
					p.death_timer = trampoline_delay # start grace period

			if stop.indexOf(prev) is not -1 # if they were bounced
				++points
				p.bounced = false # reset flag for next bounce

		# short grace time for trampoline check, so trampoline can handle
		# multiple people in-between moves
		if p.death_timer
			if --p.death_timer is 0
				return game_over! if ++misses is 3 # increment and check for gameover
				dropped = p
				break # stop processing people

		if p.position is tramp
			p.bounced = true 
			p.death_timer = 0

	if dropped
		people.splice people.indexOf( dropped ), 1 # remove person
		drop_position := pos # set where drop animation starts

		# temporarily prevent trampoline movement
		document.removeEventListener \keydown key_move
		canvas.removeEventListener \click click_move
		drop_animation!
	else
		# pop first person if they're saved
		people.shift! if people.0?position is end

		if --next_person is 0
			people.push {position:0 delay: move_delay}
			# get a normally-distributed number through the central limit theorem
			avg = 0
			avg += Math.random! * 2 - 1 for i til 16 # [-1, 1) 
			avg /= 16
			# TODO better difficulty curve
			# use frame-level granularity for more interesting play
			# in the original fire, they tend to come in waves, with the delay short
			# enough to make the player have to juggle them
			next_person := 
				( Math.floor ( avg * std_dev + end/2 - Math.pow(difficulty_curve,points) ) * move_delay ) >? move_delay

		draw! if dirty
		window.requestAnimationFrame tick # next frame
				
drop_animation = !->
	draw!
	# TODO walk off screen
	ctx.fillText "dropped!" 150 150
	
	# re-add trampoline events and start game again
	setTimeout do
		->
			document.addEventListener \keydown key_move
			canvas.addEventListener \click click_move

			# create new person if there aren't any on screen 
			next_person := 1
			draw!
			tick!
		1000ms

game_over = !->
	if points > high_score_threshold
		add_high_score points
	
	show_high_scores!

	document.removeEventListener \keydown key_move
	canvas.removeEventListener \click click_move

	canvas.addEventListener \click click_start

	# cycle gameover for 5 seconds, then display title
	cycles = 50
	current_gameover = 0
	ctx.drawImage assets.gameover1, 0 0 width, height
	cycle_gameover = !->
		ctx.clearRect 0 0 width, height
		current_gameover := (current_gameover + 1) % 3
		ctx.drawImage assets["gameover#{current_gameover + 1}"], 0 0 width, height
		if --cycles > 0
			window.setTimeout cycle_gameover, 100ms
		else
			cycle_title!

	window.setTimeout cycle_gameover, 100ms
		

start_game = !->
	people := [{position: 0, delay: move_delay}] # start with initial person
	trampoline := 1 # middle
	points := 0
	misses := 0

	# add the next person after the first person is saved
	# after that, tick! will set next_person as a poisson process
	next_person := end * move_delay

	window.clearTimeout cycle_timeout # stop title animation
	window.cancelAnimationFrame cycle_frame # edge case: stop title animation wrapper

	document.addEventListener \keydown key_move
	canvas.addEventListener \click click_move
	
	canvas.removeEventListener \click click_start
	
	hide_high_scores!

	draw!
	tick!

click_start = ({button}: e) ->
	if button is 0 # only left click
		e.preventDefault!
		start_game!

key_move = !({keyCode}: e) -> 
	if keyCode is 37 and trampoline > 0 # left
		--trampoline
	else if keyCode is 39 and trampoline < 2 # right
		++trampoline
	# TODO PAUSE
	draw!
	e.preventDefault!

click_move = !({clientX: x, button}: e) ->
	if button is 0
		# 3 equal-width zones to click
		# FIXME not considering canvas element 
		trampoline := Math.floor( x / width * 3 ) 
		draw!
		e.preventDefault!

# cheesy hand-drawn animation effect
current_title = 0
cycle_timeout = void
cycle_frame = void # Additional variable to cancel animation frame
cycle_title = !->
	ctx.clearRect 0 0 width, height
	current_title := (current_title + 1 ) % 3
	ctx.drawImage assets["title#{current_title+1}"], 0 0 width, height
	
	# wrapped in requestAnimationFrame so title won't cycle
	# when page isn't visible
	cycle_frame := window.requestAnimationFrame ->
		cycle_timeout := setTimeout cycle_title, 100ms

# add initial click to start game
cycle_title!
show_high_scores!
canvas.addEventListener \click click_start 

